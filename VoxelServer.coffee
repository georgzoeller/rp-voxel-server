#rp-voxel-server based on deathcap/voxel-server

{EventEmitter} = require("events")
DuplexEmitter = require("duplex-emitter")
extend = require("extend")
path = require("path")
uuid = require("hat")
crunch = require("voxel-crunch")
engine = require("voxel-engine")
debug = require('debug')('server:voxelServer')


module.exports = class Server extends EventEmitter

    constructor: (opts) ->
        @initialize opts

    initialize: (opts) ->

        debug "Initializing instance..."
        self = this

        # server game settings are sent to all
        # new clients when they connect
        defaults = {
            isClient: false, chunkDistance: 2,
            materials: [
                [
                    "grass",
                    "dirt",
                    "grass_dirt",
                ],
                "obsidian",
                "brick",
                "grass"
            ],
            worldOrigin: [0, 0, 0],
            controls: {discreteFire: true},
            avatarInitialPosition: [1, 1, 1],
            forwardEvents: [],
            skySpeed: 0.1
        }


        # if generator configuration is specified, load it.
        # otherwise, use default or passed in .generate function
        if opts.generators? and not opts.generate?

            debug "Loading generators..."
            @generators = generators = []

            for generator in opts.generators
                debug "[#{generators.length}] #{generator.type}(#{JSON.stringify generator.args})"
                generatorFile  = "#{__dirname}/generators/#{generator.type}"
                Generator = require generatorFile
                instance = new Generator(generator.args)
                @generators.push instance
                instance.protected = generator.protected is true

            opts.generate = (x,y,z) ->
                ret = 0
                for generator in generators
                    val = generator.generate(x,y,z)

                    # do not overwrite existing voxels with 0
                    ret = val if val > 0

                    # if the generator is set to protected, do not invoke subsequent generators to change
                    # blocks generated by it
                    if ret > 0 and generator.protected == true
                        break
                ret

        settings = self.settings = extend({}, defaults, opts)

        debug JSON.stringify settings
        self.settings = settings
        # prepare a server object to return

        self.forwardEvents = settings.forwardEvents
        game = self.game = engine(settings)

        #if (game.notCapable()) return;

        clients = self.clients = {}
        chunkCache = self.chunkCache = {}

        # send player position/rotation updates
        setInterval self.sendUpdate.bind(self), 1000 / 22 # every 45ms




        # forward some events to module consumer
        game.voxels.on "missingChunk", (chunk) ->
            debug "missingChunk"
            self.emit "missingChunk", chunk
            return

        return


    # Setup the client connection - register events, etc
    connectClient: (duplexStream, id) ->
        debug "connectClient #{id}"
        self = this
        settings = self.settings
        game = self.game

        # create 'connection' remote event emitter from duplex stream
        connection = DuplexEmitter(duplexStream)

        # register client id
        id = id or uuid()
        connection.id = duplexStream.id = id
        self.broadcast id, "join", id
        client = self.clients[id] =
        {
            id: id,
            connection: connection,
            player: {rotation: new game.THREE.Vector3(), position: new game.THREE.Vector3()}
        }

        # setup client response handlers
        self.bindClientEvents client

        # send client id and initial game settings
        connection.emit "id", id
        connection.emit "settings", settings

        return

    removeClient: (id) ->
        self = this
        client = self.clients[id]
        delete self.clients[id]
        debug "removeClient #{id}"
        self.broadcast id, "leave", id
        return


    setBlock: (pos,val,clientId) ->
        self = this
        debug "setBlock #{pos} = #{val}"
        self.game.setBlock pos, val
        chunkPos = self.game.voxels.chunkAtPosition(pos)
        chunkID = chunkPos.join("|")
        delete self.chunkCache[chunkID]  if self.chunkCache[chunkID]

        # broadcast 'set' to all players
        self.broadcast null, "set", pos, val, clientId || -1
        return

    bindClientEvents: (client) ->
        self = this
        game = self.game
        id = client.id
        connection = client.connection

        # forward chat message
        connection.on "chat", self.handleErrors((message) ->

            # ignore if no message provided

            # limit chat message length
            message.text = message.text.substr(0, 140) if (message.text.length > 140)
            debug "chat: #{message}"
            self.broadcast null, "chat", message  unless message.text
        )

        # when user ready ( game created, etc )
        connection.on "created", self.handleErrors(->
            debug 'Client Created'
            # send initial world payload
            self.sendInitialChunks connection

            # emit client.created for module consumers
            self.emit "client.created", client
            return
        )

        # client sends new position, rotation
        connection.on "state", self.handleErrors((state) ->
            #debug "state #{id} #{JSON.stringify state}"
            client.player.rotation.x = state.rotation.x
            client.player.rotation.y = state.rotation.y
            pos = client.player.position
            distance = pos.distanceTo(state.position)
            if distance > 20
                before = pos.clone()
                pos.lerp(state.position, 0.1)
                return
            pos.copy(state.position)
            self.emit "client.state", client, state
            return
        )


        # client modifies a block
        chunkCache = self.chunkCache
        connection.on "set", self.handleErrors((pos, val) ->
            self.setBlock pos,val,client.id
            return
        )

        # forward custom events
        self.forwardEvents.map (eventName) ->
            connection.on eventName, ->
                args = [].slice.apply(arguments)

                # add event name
                args.unshift eventName

                # add client id
                args.unshift id
                self.broadcast.apply self, args
                return

            return

        return


    # send message to all clients
    broadcast: (id, event) ->
        self = this

        # normalize arguments
        args = [].slice.apply(arguments)

        # remove client `id` argument
        args.shift()

        # emit on self for module consumers, unless specified not to
        self.emit.apply self, args  if id isnt "server"
        Object.keys(self.clients).map (clientId) ->
            return  if clientId is id
            connection = self.clients[clientId].connection

            # emit over connection
            try
                connection.emit.apply connection, args
            catch err
                debug "removing erroring client", clientId, err
                self.removeClient clientId
            return

        return


    # broadcast position, rotation updates for each player
    sendUpdate: ->
        self = this
        clientIds = Object.keys(self.clients)
        return  if clientIds.length is 0
        update =
            positions: {}
            date: +new Date()

        clientIds.map (id) ->
            client = self.clients[id]
            update.positions[id] =
                position: client.player.position
                rotation: {x: client.player.rotation.x, y: client.player.rotation.y}

            return

        self.broadcast null, "update", update
        return


    # send all the game chunks
    sendInitialChunks: (connection) ->
        self = this
        chunks = self.game.voxels.chunks
        chunkCache = self.chunkCache
        debug 'Sending initial chunks...'
        Object.keys(chunks).map (chunkID) ->
            chunk = chunks[chunkID]
            encoded = chunkCache[chunkID]
            unless encoded
                encoded = crunch.encode(chunk.voxels)
                chunkCache[chunkID] = encoded
            connection.emit "chunk", encoded, {position: chunk.position, dims: chunk.dims, length: chunk.voxels.length}

            return

        debug 'noMoreChunks'
        connection.emit "noMoreChunks", true
        return


    # utility function
    # returns the provided function wrapped in a try-catch
    # emits errors to module consumer
    handleErrors: (func) ->
        self = this
        # coffeelint: disable=missing_fat_arrows
        ->
            try
                return func.apply(this, arguments)
            catch error
                debug "handleErrors #{error}"
                self.emit "error", error
            return
        # coffeelint: enable=missing_fat_arrows

